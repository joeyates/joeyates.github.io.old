--- 
layout: post
typo_id: 84
title: Rake::Builder
---
{% codeblock Use Rake::Builder as a Make Replacement - build.sh %}
$ rake build
{% endcodeblock %}

I've put together a rake-based system for building C and C++ projects.

<p>
I've called it Rake::Builder, it's available on GitHub <a href="http://github.com/joeyates/rake-builder">here</a>.
</p>

<!--more-->

<h2>autoconf</h2>

<p>
Build systems are complicated by external dependencies: finding third-party headers and libraries. Often there is a specific configuration for each operating system and distribution.
</p>

<p>
The standard system is GNU's autoconf system, but it is a nightmare. At the most simple level, you distribute source code with a Makefile.<br/>
The problem is that Makefiles are just pure dependency managers - if they don't find what they need, they just fail.<br/>
The solution to that problem is the use of <string>configure</strong>. Configure runs a series of compatibility tests, sniffs the host system and spits out a Makefile.<br/>
So, with configure, the user then does the following:
<typo:code lang="shell">
$ ./configure
$ make
$ sudo make install
</typo:code>
</p>

But, configure itself is a long file, and it's is a program: about 6000 lines of shell code.

A few lines:
    ac_ext=cpp
    ac_cpp='$CXXCPP $CPPFLAGS'
    ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
    ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'

The solution to having to maintain configure? Generate it!

With autotools, there is a seemingly eternal regress of configuration files and scripts generated by other scripts.

This was my project's root directory listing before I gave up on autoconf:<br/>
    AUTHORS
    COPYING
    ChangeLog
    EXAMPLE
    INSTALL
    Makefile
    Makefile.am
    Makefile.in
    NEWS
    README
    aclocal.m4
    autom4te.cache
    config.h
    config.h.in
    config.log
    config.status
    configure
    configure.ac
    depcomp
    include
    install-sh
    missing
    objects
    src
    stamp-h1
    test

Fifteen of those files are involved in the mechanics of autoconf.

{% img /images/autoconf.png autoconf dependencies %}

Autoconf doesn't really address the issue of building on various systems and adapting semi-automatically. You still have to add all the settings, but you have to learn where in a myriad of files these settings are to be placed.

## Rake

Of the autoconf alternatives, rake seems to offer the cleanest solution. Rake itself was apparently created as a build system for C, but out of the box it's too generic: it's simply a dependency handling system.

There are already a number of specializations of rake. In Rails projects, and Gem building, Rakefiles handle maintenance, testing, documentation building and packaging.

{% codeblock Rake::Builder's Rakefile - Rakefile %}
spec = Gem::Specification.new do |s|
  s.name             = 'rake-builder'
  s.summary          = 'Rake for C/C++ Projects'
  s.description      = 'Provides Rake:Builder, a specific rake TaskLib for building C, C++, Objective-C and Objective-C++ projects'
  s.version          = Rake::Builder::VERSION::STRING

  s.homepage         = 'http://github.com/joeyates/rake-builder'
  s.author           = 'My Name'
  s.email            = 'my.email@xmail.com'

  s.files            = ADMIN_FILES +
                       SOURCE_FILES +
                       EXAMPLE_SOURCE_FILES +
                       EXAMPLE_EXTRA_FILES
  s.require_paths    = [ 'lib' ]
  s.add_dependency( 'rake', '>= 0.8.7' )

  s.has_rdoc         = true
  s.rdoc_options     += RDOC_OPTS
  s.extra_rdoc_files = RDOC_FILES

  s.test_files       = SPEC_FILES
end
{% endcodeblock %}

<p>
Rake::Builder is my attempt to specialise rake to the task of building C and C++ projects.<br />
I've got to version 0.0.11 and it now builds the following types of projects:
<ul>
	<li>C++,</li>
	<li>QT C++,</li>
	<li>C</li>
	<li>Objective-C</li>
</ul>
</p>

<p>
This is an example with two build targets: a static library and a test executable, with the test project depending on the library:

{% codeblock Rakefile for a C++ Library - Rakefile %}
require 'rake/builder'

Rake::Builder.new do |builder|
  builder.target               = 'libactive_record_sqlite.a'
  builder.source_search_paths  = [ 'src' ]
  builder.header_search_paths  = [ 'include/**/*.h' ]
  builder.objects_path         = 'objects'
  builder.include_paths        = [ 'include' ]
  builder.library_dependencies = [ 'sqlite3' ]
end

Rake::Builder.new do |builder|
  builder.task_namespace       = :test
  builder.target               = 'active_record_test'
  builder.source_search_paths  = [ 'test' ]
  builder.header_search_paths  = [ 'test' ]
  builder.objects_path         = 'test/lib_objects'
  builder.include_paths        = [ 'include', 'test' ]
  builder.library_dependencies = [ 'sqlite3', 'gtest', 'gtest_main', 'active_record_sqlite' ]
  builder.library_paths        = [ 'objects' ]
  builder.target_prerequisites = [ :'rake:build' ]
  builder.default_task         = [ :run ]
end
{% endcodeblock %}

<p>
I'm about to start using Rake::Builder on a sizable C++ project using QT, so I'll have a chance to see if it handles real world stuff without turning into autoconf.
</p>
